---
title: 条件测试
---

<Alert type="info">

## <Icon name="graduation-cap"></Icon> 你将学习

- 何时应该基于条件测试
- 不可能进行条件测试的情况
- 条件测试的常见场景策略

</Alert>

## 定义

条件测试指的是通用的编程模式:

> If X, then Y, else Z

许多用户询问如何在Cypress中完成这个看似简单的习惯用语.

下面是一些示例用例:

- 一个元素可能存在，我怎么做不同的事情?
- 我的应用开展A/B测试，该怎么处理?
- 我的新用户会收到一个“欢迎向导”，但现有老用户不会.当向导显示时，我可以关闭它吗? 当向导不显示时，我可以忽略它吗?
- 如果[cy.get()](/api/commands/get)没有找到元素，我可以从失败的Cypress命令中恢复吗?
- 我正在尝试编写动态测试，根据页面上的文本做一些不同的事情.
- 我想自动找到所有的`<a>`元素，并根据我找到的结果，想检查每个链接是否有效.

问题是——虽然一开始看起来很简单，但以这种方式编写测试通常会导致不可靠的测试、随机失败和难以跟踪边缘情况。

让我们来研究一下为什么以及如何克服这些问题...

## 问题

现在，现代JavaScript应用程序是高度动态和可变的。它们的状态和DOM在一段时间内不断变化.

条件测试的问题是，它只能在状态稳定时使用. 在现代应用程序中，通常不可能知道什么时候状态是稳定的.

对于人类来说，如果某样东西在10毫秒或100毫秒后发生了变化，我们甚至可能不会注意到这种变化，并认为状态始终不变.

对一个机器人来说，即使是10毫秒也代表了数十亿个时钟周期。时间上的差异是难以置信的.

人类也有直觉。如果单击一个按钮并看到一个加载菊花，您将假定状态处于变化中，并将自动等待它完成.

机器人没有直觉——它会完全按照程序所设定的去做.

为了说明这一点，让我们举一个简单的例子，试着按条件来测试不稳定状态.

### DOM是不稳定的

```js
// 您的应用程序代码

// 随机时间
const random = Math.random() * 100

// 创建一个<button>元素
const btn = document.createElement('button')

// 把它附加到body上
document.body.appendChild(btn)

setTimeout(() => {
  // 在不确定的时间后添加active class
  btn.setAttribute('class', 'active')
}, random)
```

```js
// 您的Cypress测试代码
it('根据按钮的class 会有什么不同吗', () => {
  // 反复运行这个测试，它有时为真，有时为假。
  cy.get('button').then(($btn) => {
    if ($btn.hasClass('active')) {
      // 如果它是active ，做...
    } else {
      // 做其他的事情
    }
  })
})
```

你看到问题了吗?这个测试是非确定性的. `<button>`有时有class `active`，有时没有. 在**大多数**情况下，不能依靠DOM的状态来决定应该有条件地做什么。

这是脆弱测试的核心. 在Cypress，我们设计了我们的API，以在每一步都与这种脆弱类型作斗争.

## 现状

在DOM上进行有条件的测试的唯一方法是，如果您100%确定状态已经“解决”，并且不可能改变它。

在任何其他情况下，如果您试图依赖DOM的状态进行条件测试，那么您将会遇到不稳定的测试.

让我们探讨几个例子。

### 服务器端渲染

如果您的应用程序是服务器端渲染的，没有异步修改DOM的JavaScript代码，祝贺您，您可以在DOM上进行有条件测试!

为什么?因为如果DOM在`load`事件发生后不改变，那么它可以准确地表示一个稳定的真实状态.

您可以安全地跳到下面，在那里我们提供了条件测试的示例。

### 客户端渲染

然而，在现在的大多数应用程序中——当`load`事件发生时，通常屏幕上什么也没有，此时脚本开始加载动态内容并开始异步渲染。

不幸的是，您不可能使用DOM来进行条件测试。否则，你需要100%保证你的应用程序已经完成了所有的异步渲染，并且没有挂起的网络请求、setTimeout、interval、postMessage或async/await代码。

如果不对应用程序进行更改，这是很难做到的(如果不是不可能的话). 你可以使用[Zone.js](https://github.com/angular/angular/tree/master/packages/zone.js) 这样的库，但即使这样,也不能捕获所有可能的异步。

换句话说，如果您希望您的测试100%一致地运行，您就不能安全地进行条件测试.

但是不要担心——有更好的解决方案，可以在不依赖DOM的情况下实现条件测试。 你必须将自己锚定在另一个不可改变的真相上.

## 策略

如果您不能保证DOM是稳定的——不要担心，还有其他方法可以进行条件测试或解决它所固有的问题.

**你可以:**

- 不做条件测试.
- 强制应用程序具有确定性的行为.
- 检查其他源的事实(如服务器或数据库).
- 将数据嵌入到其他可以读取的地方(cookie或本地存储).
- 向DOM添加可以读取的数据，以了解如何继续.

让我们来探讨一些条件测试的例子，这些测试有可能100%通过，也有可能100%不通过.

### A/B 活动

在这个例子中，让我们假设您访问您的网站，内容将根据您的服务器A/B活动策略有所区别. 它可能基于地理位置、IP地址、一天中的时间、地区或其他难以控制的因素. 如何为这种方式编写测试?

控制发送的活动，或者提供一个可靠的方法来知道是哪个活动。

#### 使用URL查询参数:

```js
// 告诉你的后端服务器你想发送的活动
// 所以你可以确定地提前知道它是什么
cy.visit('https://app.com?活动=A')

...

cy.visit('https://app.com?活动=B')

...

cy.visit('https://app.com?活动=C')
```

现在甚至不需要做条件测试，因为你可以提前知道发送了什么活动. 是的，这可能需要服务器端更新，但如果你想测试，你必须让一个不可测试的应用程序可测试!

#### 使用服务:

或者，如果你的服务器用一个session保存活动，你可以让你的服务器告诉你你在哪个活动.

```js
// 这将给我们发送会话cookie
cy.visit('https://app.com')

// 假设这能把活动信息传回来
cy.request('https://app.com/me')
  .its('body.campaign')
  .then((活动) => {
    // 根据活动类型运行不同的cypress测试代码
    return campaigns.test(campaign)
  })
```

#### 使用会话cookie:

另一种测试方法是，您的服务器在会话cookie中发送活动，您可以读取.

```js
cy.visit('https://app.com')
cy.getCookie('campaign').then((活动) => {
  return campaigns.test(活动)
})
```

#### 在DOM中嵌入数据:

另一种有效的策略是直接将数据嵌入到DOM中，但要以**始终**显示该数据并可查询的方式进行。它必须在100%的时间内存在，否则这将不起作用。

```js
cy.get('html')
  .should('have.attr', 'data-campaign')
  .then((活动) => {
    return campaigns.test(活动)
  })
```

### 欢迎向导

在本例中，让我们假设您正在运行一系列测试，每次加载应用程序时，它可能会显示一个“欢迎向导”模式.

在这种情况下，您希望在向导存在时关闭它，如果不存在则忽略它.

这样做的问题是，如果向导异步呈现(很可能是这样)，您就不能使用DOM有条件地关闭它.

同样，我们需要另一种不涉及DOM的可靠方法来实现这一点.

这些模式和以前几乎一样:

#### 使用URL来控制它:

```js
// 不要显示向导
cy.visit('https://app.com?wizard=0')
```

```js
// 显示向导
cy.visit('https://app.com?wizard=1')
```

我们可能需要更新我们的客户端代码来检查这个查询参数是否存在。现在我们提前知道它是否会被展示。

#### 使用cookie提前知道:

在你无法控制它的情况下，如果你知道它是否会被显示，你仍然可以有条件地取消它。

```js
cy.visit('https://app.com')
cy.getCookie('showWizard')
  .then((val) => {
    if (val) {
      // 通过附加这三个命令，有条件地关闭向导
      cy.get('#wizard').contains('Close').click()
    }
  })
  .get(...)    // 在这里更多的命令
  .should(...) // 在这里更多的命令
  .click()     // 在这里更多的命令
```

#### 使用您的服务器或数据库:

如果您服务端存储或保持是否显示向导，请询问它。

```js
cy.visit('https://app.com')
cy.request('https://app.com/me')
  .its('body.showWizard')
  .then((val) => {
    if (val) {
      // 通过附加这三个命令，有条件地关闭向导
      cy.get('#wizard').contains('Close').click()
    }
  })
  .get(...)    // more commands here
  .should(...) // more commands here
  .click()     // more commands here
```

或者，如果您正在创建用户，那么创建用户并设置是否希望提前显示向导可能会花费更少的时间。这样能避免之后的检查。

#### 在DOM中嵌入数据:

另一种有效的策略是将数据直接嵌入DOM，但要以数据始终存在并可查询的方式进行。数据必须在100%的时间内呈现，否则该策略将不起作用。

```js
cy.get('html').should('have.attr', 'data-wizard').then((wizard) => {
  if (wizard) {
    // 通过附加这三个命令，有条件地关闭向导
    cy.get('#wizard').contains('Close').click()
  }
})
.get(...)    // more commands here
.should(...) // more commands here
.click()     // more commands here
```

### 元素存在

在尝试使用DOM进行条件测试的情况下，可以利用同步查询Cypress中的元素的能力来创建控制流。

<Alert type="warning">

如果你没有阅读上面的内容，跳到这里，我们将再次重申:

除非您是其中之一，否则无法对DOM进行条件测试:

- 服务器端渲染模式，没有异步JavaScript代码.
- 使用JavaScript，但是只以同步方式渲染客户端.

理解应用程序是如何工作的至关重要，否则您将编写不可靠的测试。

</Alert>

假设我们有这样一个场景，我们的应用程序可能做两件我们无法控制的事情. 换句话说，您尝试了上面的每一种策略，但由于某种原因，您无法提前知道您的应用程序将做什么。

Cypress是可以做这种测试的。

```js
// 应用程序代码
$('button').on('click', (e) => {
  // 同步随机地做某事
  if (Math.random() < 0.5) {
    // 添加一个 input
    $('<input />').appendTo($('body'))
  } else {
    // 或添加一个 textarea
    $('<textarea />').appendTo($('body'))
  }
})
```

```js
// 测试代码：单击该按钮使新元素出现
cy.get('button').click()
cy.get('body')
  .then(($body) => {
    // 从body同步查询以查找创建的元素
    if ($body.find('input').length) {
      // input被找到了，在这里做些别的事情
      return 'input'
    }

    // 否则假设是 textarea
    return 'textarea'
  })
  .then((selector) => {
    // Selector是一个字符串，表示我们可以用来找到它的选择器
    cy.get(selector).type(`通过选择器找到元素 ${selector}`)
  })
```

我们再重申一次. 如果`<input>`或`<textarea>`被异步渲染，你不能使用上面的模式. 您将不得不涉及任意的延迟，但这并不适用于每一种情况，这将让测试变慢，并且仍然有可能使您的测试不稳定(并且是完全的反模式)。

Cypress是围绕创建可靠的测试而构建的. 编写良好测试的秘密是向Cypress提供尽可能多的“状态”和“事实”，并“保护它”不发出新命令，直到应用程序达到继续运行所需的状态。

做条件测试会带来一个巨大的问题- 测试编写者自己不确定给定的状态是什么。在这些情况下，进行准确测试的唯一可靠方法是以可靠和一致的方式嵌入这个动态状态。

如果您不确定是否编写了一个不可靠的测试，那么有一种方法可以解决这个问题. 多次重复测试，然后通过修改Developer Tools来控制网络和CPU。 这将创建不同的负载来模拟不同的环境(如CI). 如果你写了一个好的测试，它100%都会通过或不通过。

```js
Cypress._.times(100, (i) => {
  it(`num ${i + 1} - 有条件地测试`, () => {
    // do the conditional bits 100 times
  })
})
```

### 动态文本

基于是否存在特定文本而有条件地执行某些操作的模式与上面的元素存在是相同的.

#### 有条件地检查元素是否有特定的文本:

```js
// 这只有在100%保证body已经完全渲染而没有任何对其状态的未决更改时才有效
cy.get('body').then(($body) => {
    // 同步地请求body的文本，并根据它是否包含另一个字符串来做一些事情
    if ($body.text().includes('some string')) {
      // yup found it
      cy.get(...).should(...)
    } else {
      // nope not here
      cy.get(...).should(...)
    }
  })
```

##  错误恢复

许多用户询问如何从失败的命令中恢复。

> 如果我有错误，我可以尝试找到X，如果X失败，就去找Y

因为错误处理在大多数编程语言中是一种常见的习惯用法，尤其是在Node中，所以在Cypress中这样做似乎是合理的.

然而，这实际上是与要求进行条件测试相同的问题，只是在实现细节上略有不同。

例如，你可能想这样做:

<Alert type="danger">

<Icon name="exclamation-triangle" color="red"></Icon> 以下代码是无效的.

</Alert>

```js
//! 不能在Cypress命令中添加错误处理
//! 此代码仅用于演示错误行为
cy.get('button')
  .contains('hello')
  .catch((err) => {
    // 哦，没有找到按钮
    // (或者别的什么失败了)
    cy.get('somethingElse').click()
  })
```

如果您一直在阅读本文，那么您应该已经掌握了为什么尝试用异步呈现实现条件代码不是一个好主意。 如果测试编写人员不能准确地预测系统的给定状态，那么Cypress也不能. 错误处理没有提供任何额外的证据证明这可以确定地完成.

您应该将Cypress中的失败命令视为类似于服务器端代码中的未捕获异常. 在这些场景中不可能尝试恢复，因为系统已过渡到不可靠的状态. 相反，您通常会选择崩溃并记录日志. 当Cypress没有通过测试时——这就是它正在做的事情.退出，跳过测试中剩余的任何命令，并在日志中记录失败.

但是…为了便于讨论，让我们想象一下在Cypress中确实有错误处理。

启用此功能意味着，对于每一个命令，它都将从错误中恢复，但只有在达到每个适用的命令超时后才会恢复. 由于超时从4秒开始(并且超过4秒)，这意味着它只会在很长很长的时间之后失败。

让我们重新想象一下前面的“欢迎向导”示例.

<Alert type="danger">

<Icon name="exclamation-triangle" color="red"></Icon> 以下代码是无效的.

</Alert>

```js
//! 不能在Cypress命令中添加错误处理。
//! 此代码仅用于演示错误
function keepCalmAndCarryOn () {
  cy.get(...).should(...).click()
}

cy
  .get('#wizard').contains('Close').click()
  .catch((err) => {
    // 没问题，我猜那个向导根本不存在
    // 或者其他不用担心的……东西
    keepCalmAndCarryOn()
  })
  .then(keepCalmAndCarryOn)
```

在最好的情况下，我们至少浪费了4秒等待`<#wizard>`元素可能存在，然后才出错并继续。

但在最坏的情况下，我们有一个情况，`<#wizard>`将被渲染，但它没有在给定的超时内渲染. 让我们假设这是由于一个挂起的网络请求或WebSocket消息或队列计时器，或任何其他原因.

在这种情况下，我们不仅要等待很长一段时间，而且当`<#wizard>`元素最终被显示时，它可能会在其他命令上导致错误。

如果你不能准确地知道你的应用程序的状态，那么无论你有什么编程习惯- **你写的不是100%确定的测试**。

仍然不相信?

这不仅是一个反模式，而且是一个实际的逻辑谬误。

你可能会想…好吧，但4秒，这还不够。网络请求可能会很慢，让我们把它提高到1分钟!

即便如此，还是有可能出现WebSocket消息……所以5分钟!

即使这样，还不够，它可能是一个`setTimeout`可以触发…60分钟。

当你接近无限时，你的信心会继续上升，因为你有机会证明你想要的状态会达到，但你永远无法证明它会达到。相反，从理论上讲，你可以等待到宇宙死亡，等待一种条件的到来，而这种条件离发生只有一瞬间的时间。没有办法证明或反驳它可能有条件地发生。

作为测试编写人员，您必须提前知道您的应用程序要做什么——或者100%确信可变对象(如DOM)的状态已经稳定，以便编写准确的条件测试。
